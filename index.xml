<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aston&#39;s Programming Thoughts</title>
    <link>https://astonbitecode.github.io/blog/</link>
    <description>Recent content on Aston&#39;s Programming Thoughts</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Feb 2019 00:05:58 +0000</lastBuildDate>
    
	<atom:link href="https://astonbitecode.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JavaFX UI in Rust</title>
      <link>https://astonbitecode.github.io/blog/post/rust-javafx/</link>
      <pubDate>Thu, 28 Feb 2019 00:05:58 +0000</pubDate>
      
      <guid>https://astonbitecode.github.io/blog/post/rust-javafx/</guid>
      <description>In this post, I would like to share the way how we can implement a Rust application that has a User Interface written in JavaFX.
A brief description follows, but you may see the full code here.
General description We will create a Rust application that:
 Creates a JVM Starts a JavaFX application Accepts callbacks from the Java world and prints them in the console.  Creating a JVM from Rust code and communicating with the Java world is achieved using the j4rs crate.</description>
    </item>
    
    <item>
      <title>Akka: To ask, or not to ask?</title>
      <link>https://astonbitecode.github.io/blog/post/bang-not-ask/</link>
      <pubDate>Tue, 20 Sep 2016 06:10:10 +0000</pubDate>
      
      <guid>https://astonbitecode.github.io/blog/post/bang-not-ask/</guid>
      <description>There are times that Akka Actors need to contact some other Actor, get the response and then continue their processing.
It is debatable whether this is a good design or not. However, when designing Akka APIs to be used by different libraries/modules, it is a reality that someone may have to deal with - especially when many different teams collaborate with each other, so you don&amp;rsquo;t have access to others&amp;rsquo; code.</description>
    </item>
    
    <item>
      <title>Scala: Use fold to serialize any number of Futures</title>
      <link>https://astonbitecode.github.io/blog/post/foldfor/</link>
      <pubDate>Sun, 04 Oct 2015 08:05:58 +0000</pubDate>
      
      <guid>https://astonbitecode.github.io/blog/post/foldfor/</guid>
      <description>Scala&amp;rsquo;s for-comprehensions are extremely useful and offer much more than just looping. For this post, I would like to focus on using for-comprehensions for manipulating Futures. More specifically, for serializing Futures.
Let&amp;rsquo;s assume that we have a function that performs some kind of logic and returns a Future:
def addOneAndPrint(num: Int): Future[Unit] = { Future { val addedOne = num + 1 print(addedOne + &amp;quot; &amp;quot;) } }  Users of such a fuction, may want to call it more than one time and additionally, to call it serially.</description>
    </item>
    
    <item>
      <title>A (kind-of) Dependency Injection in Scala</title>
      <link>https://astonbitecode.github.io/blog/post/kindofdi/</link>
      <pubDate>Sat, 25 Apr 2015 08:05:58 +0000</pubDate>
      
      <guid>https://astonbitecode.github.io/blog/post/kindofdi/</guid>
      <description>The problem While projects evolve, the lines of code increase and the dependencies between the classes are becoming more and more complicated. With the absence of some Dependency Injection (DI) framework/library, this ends up quickly in having to pass instances here and there through constructors of classes. The constructors may end up having something like 10+ arguments. To make things worse, for some cases, these arguments are not used by the logic of the classes themselves, but instead, they are just used to create subclasses!</description>
    </item>
    
    <item>
      <title>OSGi: Finding the way to JEE and JSF</title>
      <link>https://astonbitecode.github.io/blog/post/osgijsf/</link>
      <pubDate>Thu, 05 Mar 2015 08:05:58 +0000</pubDate>
      
      <guid>https://astonbitecode.github.io/blog/post/osgijsf/</guid>
      <description>Note: You may find the complete source code for this tutorial here.
Combining the modularity offered by OSGi with the EE technologies may result to powerful, scalable and maintainable applications.
Eclipse Virgo bridges OSGi and JEE worlds and provides a “completely module-based Java application server”.
Even if the Virgo documentation provides detailed explanations, it seemed difficult to find tutorials that are functional and build up to a JEE Web application that is powered by OSGi bundles and services.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://astonbitecode.github.io/blog/page/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://astonbitecode.github.io/blog/page/about/</guid>
      <description>In this blog, I post anything that might help someone, or (hopefully) even inspire.
&amp;ldquo;Probably I am very naive but I also think I prefer to remain so&amp;rdquo;
Edsger W. Dijkstra</description>
    </item>
    
  </channel>
</rss>