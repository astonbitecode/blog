<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>A (kind-of) Dependency Injection in Scala &middot; Aston</title>

  
  <link rel="stylesheet" href="https://astonbitecode.github.io/blog/css/poole.css">
  <link rel="stylesheet" href="https://astonbitecode.github.io/blog/css/hyde.css">
  <link rel="stylesheet" href="https://astonbitecode.github.io/blog/css/poole-overrides.css">
  <link rel="stylesheet" href="https://astonbitecode.github.io/blog/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://astonbitecode.github.io/blog/css/hyde-x.css">
  <link rel="stylesheet" href="https://astonbitecode.github.io/blog/css/highlight/zenburn.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://astonbitecode.github.io/touch-icon-144-precomposed.png">
  <link href="https://astonbitecode.github.io/favicon.png" rel="icon">

  
  
  
  

  <meta name="description" content="This is a new page">
  <meta name="keywords" content="default,page,keywords">
  
</head>
<body class="theme-base-0c">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
      <h1>Aston</h1>
      <p class="lead">Sharing some thoughts and solutions, hoping it might be helpful for someone&hellip;</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="https://astonbitecode.github.io/">Blog</a></li>
      
      <li class="sidebar-nav-item"><a href="https://astonbitecode.github.io/blog/page/about/">About</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/astonbitecode"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      <a href="https://astonbitecode.github.io/index.xml" type="application/rss+xml"><i class="fa fa-rss-square fa-3x"></i></a>
      </li>
    </ul>

    

    <p>Copyright &copy; 2016 <a href="https://astonbitecode.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">A (kind-of) Dependency Injection in Scala</h1>
    <span class="post-date">Apr 25, 2015 &middot; 7 minute read
    
    <br/>
    
    </span>
    

<h2 id="the-problem">The problem</h2>

<p>While projects evolve, the lines of code increase and the dependencies between the classes are becoming more and more complicated. With the absence of some Dependency Injection (DI) framework/library, this ends up quickly in having to pass instances here and there through constructors of classes. The constructors may end up having something like 10+ arguments. To make things worse, for some cases, these arguments are not used by the logic of the classes themselves, but instead, they are just used to create subclasses!</p>

<p>This situation is especially common for projects that are built using a service-oriented architecture internally and of course, makes things tight and difficult during Unit Testing.</p>

<p>Dependency Injection may help keeping the code (mostly) clean and can facilitate the implementation of Unit Tests. However, it is not the choice for everyone and some teams may have decided not to use any DI framework.</p>

<h2 id="the-thought-for-a-way-out">The thought for a way out</h2>

<p>Scala is a very expressive language and it is pretty amazing how beautiful things someone can achieve when using it. We can see this everywhere: in blogs, SO and gists to name a few.
So, maybe we could find some delicate and easy way to keep the code cleaner, even without the use of any specific DI libraries.</p>

<h2 id="a-kind-of-di">A kind of DI</h2>

<p>As Jonas Bonér (founder and CTO of Typesafe) says in his blog: “Scala is a very rich and deep language that gives you several ways of doing DI solely based on language constructs”.</p>

<p>In the same blog, he describes a way to perform DI using the Cake Pattern. Searching around the blogs and answers/proposals, one may find out that indeed, DI in Scala can be achieved with several ways.</p>

<p>What we will try to do here, is a kind of DI using Scala-only constructs, in order to be able to create some class instance once and “inject” it wherever is needed.</p>

<h2 id="use-case-to-drive-the-solution">Use case to drive the solution</h2>

<p>Let&rsquo;s say that we have a class that represents a Configuration Service. This service provides a file path to its users. The service should be used by any class in our application that needs it and it may look like this:</p>

<pre><code class="language-scala">class ConfigurationService(filePath: String) {
  def getFilePath(): String = filePath
}
</code></pre>

<h2 id="who-will-instantiate-the-service">Who will instantiate the service?</h2>

<p>In a real DI framework, the container/framework itself should instantiate the ConfigurationService, as being dictated by some XML configuration or annotations, like in Spring.</p>

<p>In this case however, the service will be created by our code, during the startup of the application and before any class asks for it.</p>

<h2 id="a-package-object-in-the-solution">A package object in the solution</h2>

<p>A package object is really helpful because any definition that is done inside the package object is actually member of the package itself. A package object (and a Scala object in general) can provide access to its fields and methods from anywhere in our code.</p>

<p>So, someone could think to create an object like following:</p>

<pre><code class="language-scala">package object di {
  var configurationService: ConfigurationService = _
}
</code></pre>

<p>However, there are some things that need our attention. Firstly, we need to obey to the functional principle that dictates the use of vals instead of vars.</p>

<p>So, the service should be available to the users immutably, via a val.
But how this can be done, since the object will be already created by the time that our application performs the initialization of the service? Well, a small hack including a lazy val and a var could do the trick:</p>

<pre><code class="language-scala">package object di {
  private var configurationServiceVar: ConfigurationService = _
  lazy val configurationService: ConfigurationService = configurationServiceVar
}
</code></pre>

<p>Now the di object offers the ConfigurationService publicly via a val. All we need now is a def that allows the mutation of the var.
This mutation should be done early in out Application initialization, before someone asks for the val. If not, the configurationService val will be null during the lifetime of our application.</p>

<p>Let&rsquo;s try to avoid that by using Options and Exceptions:</p>

<pre><code class="language-scala">package object di {
  private var configurationServiceVar: Option[ConfigurationService] = None
 
  lazy val configurationService: ConfigurationService = {
    configurationServiceVar.getOrElse(throw new RuntimeException(&quot;Configuration is not yet initialized&quot;))
  }
 
  def initService(cs: ConfigurationService) = configurationServiceVar = Some(cs)
}
</code></pre>

<p>With the above code, we are making sure that if someone asks for the ConfigurationService before it gets initialized, he/she will get a nice RuntimeException. Moreover, the RuntimeException will prevent setting the val with something wrong like None.</p>

<p>Our lazy val will stay uninitialized until someone actually initializes it.</p>

<h2 id="making-it-generic">Making it generic</h2>

<p>Until now, the solution handles only the ConfigurationService class. Let&rsquo;s try to make it more useful, by handling more services generically:</p>

<pre><code class="language-scala">package object di {
  private var readyToInject: Map[Class[_], Any] = TrieMap.empty
 
  private def key[T](implicit classTag: ClassTag[T]): Class[_] = classTag.runtimeClass
 
  def initService[T: ClassTag](c: T) {
    val k = key[T]
    readyToInject.get(k) match {
      case Some(initialized) =&gt; throw new RuntimeException(&quot;The service already initialized&quot;)
      case None =&gt; readyToInject = readyToInject += (k -&gt; c) 
    }
  }
 
  def inject[T: ClassTag]: T = {
    readyToInject.get(key[T]).getOrElse(throw new RuntimeException(&quot;The service is not yet initialized&quot;)).asInstanceOf[T]
  }
}
</code></pre>

<p>We created a concurrent Map that has a Class as key and Any as value. The potential is that the Map will hold the instances that will be later injected into fields of classes that need them.</p>

<p>We also changed the name of the initService method to inject. This is just to add a bit more “beauty”, as it will make the code easier to understand and to look familiar to us (similarly to @inject annotation).</p>

<h2 id="how-this-kind-of-di-looks-like-to-its-users">How this kind of DI looks like to its users?</h2>

<p>Let&rsquo;s create a user of the ConfigurationService, a HelpfulClass:</p>

<pre><code class="language-scala">class HelpfulClass {
  private val config = inject[ConfigurationService]
 
  def doSomethingUsingTheConfiguration = {
    println(config.getFilePath())
  }
}
</code></pre>

<p>This seems simple and elegant. We expect our config val to have “injected” an instance of the ConfigurationService class, only by issuing:</p>

<pre><code class="language-scala">private val config = inject[ConfigurationService]
</code></pre>

<p><em>Note:</em> For this example and for the sake of simplicity, the ConfigurationService was a concrete class. However, it could also be a trait.</p>

<p>Let&rsquo;s see what is the result
We may test the result by creating a simple Main object and try to see the following:</p>

<ol>
<li>We will try to use the HelpfulClass before the ConfigurationService is created in order to get the resulted exception.</li>
<li>We will initialize and use the ConfigurationService.</li>
<li>We will try to use the HelpfulClass again in order to get the resulted exception.</li>
</ol>

<pre><code class="language-scala">object Main extends App {
  // Try to use the service before it gets initialized (1)
  try {
    val helpfulClassShouldFail = new HelpfulClass
  } catch {
    case error: Exception =&gt; println(error.getMessage)
  }
 
  // Initialize services (like the DI framework would do)
  initService(new ConfigurationService(&quot;/my/path&quot;))
 
  // Run the application (2)
  val helpfulClass = new HelpfulClass
  helpfulClass.doSomethingUsingTheConfiguration
 
  // Try to re-initialize the service (3)
  try {
    initService(new ConfigurationService(&quot;/my/other/path&quot;))
  } catch {
    case error: Exception =&gt; println(error.getMessage)
  }
}
</code></pre>

<p>Once this runs, we should see the output:</p>

<p>Configuration is not yet initialized
/my/path
Configuration is already initialized</p>

<h2 id="drawbacks-and-possible-extensions">Drawbacks and possible extensions</h2>

<p>The main drawback is that it is dangerous to use this kind of DI to inject values into Scala objects. In the case that someone tries to use the object before the ConfiguratioService gets initialized, the application will crash with an ExceptionInInitializerError.</p>

<p>The other thing that doesn&rsquo;t allow me to call this proper DI, is that the inversion of control is not applied in a proper way. The control of the services creation is still in our own code.</p>

<p>One way to try to abstract away of explicitly creating the instances of services in the code, could be to create logic inside the di package object that would read some XML file and do the instantiation of services using reflection, during the startup of the Application.</p>

<p>Moreover, we could even try to create scopes and, like in Spring for example, support singleton, prototype etc!</p>

<p>##What to takeaway?
The idea, if you like it and the code, of course. It is pushed in a GitHub repo.</p>

<p>Thanks for reading!</p>

  </div>
  
</div>




<script src="https://astonbitecode.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

